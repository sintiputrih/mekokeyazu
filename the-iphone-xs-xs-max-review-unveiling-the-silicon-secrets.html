<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>The Apple A12 - First Commercial 7nm Silicon | BlinkD</title><meta name=generator content="Hugo 0.98.0"><meta name=description content="Over the last few years Apple’s silicon design teams have been at the forefront of both architecture design and adopting bleeding-edge manufacturing processes. The Apple A12 is yet another generational jump for the company, as it’s able to claim to be the first commercially available piece of 7nm silicon.
When talking about process nodes, generally speaking the smaller the figure, the smaller the transistor features are. While the actual name of recent nodes have long lost any meaning in correlation to actual physical sizes, they still represent a jump in density, and thus, the ability for vendors to pack in more transistors in the same die space."><link rel=stylesheet href=https://assets.cdnweb.info/hugo/cayman/css/normalize.css><link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700" rel=stylesheet type=text/css><link rel=stylesheet href=https://assets.cdnweb.info/hugo/cayman/css/cayman.css><link rel=apple-touch-icon sizes=180x180 href=./apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=./favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=./favicon-16x16.png><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css integrity=sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js integrity=sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script></head><body><section class=page-header><h1 class=project-name>BlinkD</h1><h2 class=project-tagline></h2><nav><a href=./index.html class=btn>Blog</a>
<a href=./sitemap.xml class=btn>Sitemap</a>
<a href=./index.xml class=btn>RSS</a></nav></section><section class=main-content><h1>The Apple A12 - First Commercial 7nm Silicon</h1><div><strong>Publish date: </strong>2024-01-28</div><p>Over the last few years Apple’s silicon design teams have been at the forefront of both architecture design and adopting bleeding-edge manufacturing processes. The Apple A12 is yet another generational jump for the company, as it’s able to claim to be the first commercially available piece of 7nm silicon.</p><p>When talking about process nodes, generally speaking the smaller the figure, the smaller the transistor features are. While the actual name of recent nodes have long lost any meaning in correlation to actual physical sizes, they still represent a jump in density, and thus, the ability for vendors to pack in more transistors in the same die space.</p><p>We thank TechInsights for publicly sharing their picture of the Apple A12, and we’ve <a href=#>followed up with posting a quick first analysis reaction to the die shot</a>:</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/13392/A12_575px.jpg style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a><br>AnandTech modified&nbsp;<a href=#>TechInsights Apple A12</a>&nbsp;Die Shot</p><p>Going over it again here for this article, I’ve put down my own custom labelling and interpretation of the die shot. The new A12 largely follows Apple’s SoC layout structure (90° rotated to most past die shots).</p><p>On the right side we see the GPU complex with the four GPU cores and shared logic in the middle. The CPU complex is found at the bottom, with the two Vortex big CPU cores on the centre-left, divided by the big L2 cache, right next to the four small Tempest CPU cores and their own L2 cache.</p><p>The four big chunks of SRAM in the middle blocks are part of the system cache – this is a SoC-wide cache layer in between the memory controllers and the internal system interconnect & block memory subsystems. Here Apple uses this block as an energy saving feature: Because memory transactions to DRAM are quite expensive in terms of energy usage, being able to cache things on-chip will save a great amount of power, with the added benefit of possible performance increases due to the locality of the data.</p><p>The Apple A12’s system cache has, to date,&nbsp;seen the biggest change since its introduction in the Apple A7. The big change in layout also points out to a large change in the functionality of the block, as now we clearly see a separation of the block into what’s apparent to be four slices. On previous Apple SoCs such as in the A11 or A10, the system cache looked more like a single block of logic, with what appeared to be two slices. A doubling of the slices could possibly point out to a very large change in the memory performance of this block – something I very much believe to be the case following more analysis in the coming pages.</p><p>Finally, the last big introduction in the A12 is a major revamp of the neural accelerator IP. Here Apple claims to have moved from a dual-core design found in the A11, to a new 8-core design.&nbsp;<span>Last year’s design was rumoured to be a CEVA IP – although we’ve never have full confirmation on that as Apple doesn’t want it to be known.</span><span>&nbsp;</span></p><p>During the keynote presentation it’s important to note that Apple never mentioned that this is an in-house design, something the marketing materials was always eager to point out for other IP blocks of the SoCs.</p><p><strong>Edit:</strong> I've been notified that Apple does have the "<a href=#>Apple-designed</a>" mention on the A12 webpage, meaning this does indeed mean it's an in-house IP.</p><p><span>The A12 being an 8-core design would point out to a 4x increase in performance – but the actual increase is near 8x, increasing from 600GigaOPs in the A11 to 5TeraOPs in the A12. In the die shot we see the 8 MAC engines surrounding a big central cache, with possible shared logic at the top that would be responsible for fixed function and fully connected layer processing.</span></p><table border=1 cellpadding=0 cellspacing=0><tbody readability=2><tr class=tgrey readability=2><td colspan=3>Die Block Comparison (mm²)</td></tr><tr class=tlblue><td class=contentwhite>SoC<p>Process Node</p></td><td class=contentwhite>Apple A12<p>TSMC N7</p></td><td class=contentwhite>Apple A11<p>TSMC 10FF</p></td></tr><tr><td class=tlgrey><strong>Total Die</strong></td><td>83.27</td><td>87.66</td></tr><tr><td class=tlgrey><strong>Big Core</strong></td><td>2.07</td><td>2.68</td></tr><tr><td class=tlgrey><strong>Small Core</strong></td><td>0.43</td><td>0.53</td></tr><tr readability=2><td class=tlgrey><strong>CPU Complex (incl. cores)</strong></td><td>11.90</td><td>14.48</td></tr><tr><td class=tlgrey><strong>GPU Total</strong></td><td>14.88</td><td>15.28</td></tr><tr><td class=tlgrey><strong>GPU Core</strong></td><td>3.23</td><td>4.43</td></tr><tr><td class=tlgrey><strong>NPU</strong></td><td>5.79</td><td>1.83</td></tr></tbody></table><p>Looking over the different block size changes from the A11 to the A12, we see the benefits of TSMC’s newer 7nm manufacturing node. It’s to be noted that nearly all IP blocks have undergone changes, so it’s not really a valid apples-to-apples comparison to determine just how much density has improved with the new manufacturing node. Still, taking a single GPU core as a possible candidate (as we largely see the same structure), we see a 37% decrease in size compared to the A11. It’s quite obvious that the new node has enabled Apple to add an additional GPU core even though in absolute terms, the GPU is still smaller in the A12.</p><h3>A bigger CPU and a massive cache hierarchy</h3><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/13392/A12-CPU_575px.jpg style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a><br>Credit:&nbsp;<a href=#>TechInsights Apple A12</a>&nbsp;Die Shot, <a href=#>ChipRebel Apple A11</a> Die Shot</p><p>Moving on to the CPU complex, and in particular the new big CPU core, we now see what is possibly Apple’s biggest change in its CPU layout in several generations. In particular, we see a doubling of the L1 data caches in the new Vortex CPU, increasing from 64KB to 128KB in the new core. In the front-end, we also saw a doubling of the SRAM blocks that I attribute to the L1 instruction caches – which I now believe to have also seen doubling to 128KB. It’s funny that even after several years, we still haven’t really figured out what the A10 had introduced into the front-end block: here we saw a new very large block of cache whose function largely remains unclear.</p><p align=center><a href=#><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/13392/Cache-Size-Lat-A11-A12_575px.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>A big question over the years has been what Apple’s cache hierarchy actually looks like. Looking at the memory latency behaviour at different test depths, we see the different jumps at different test depths. I didn’t annotate the latency values as we’ll revisit them later in a non-logarithmic version of this graph.</p><p>On the big core side, we clearly see the L1$ jump from 64KB to 128KB, and I think there’s no doubt about the increases here. Moving into the L2 cache however, we’re seeing some odd behaviour in terms of the latency. It’s clear that around the 3MB range that there’s an increasing jump in latency, up until around 6MB. It’s to be noted that this behaviour of a slower second 3MB only happens when accessing in a fully random patterns, in smaller access windows the latency is flat up until 6MB.</p><p>Not dwelling more into this for now, we move into the area beyond 6MB that is served by the system cache. It’s hard to make it out at first because there’s an offset caused by overall lower latency, but in general the latency curve goes around 4MB further before we reach mostly DRAM latencies. This corresponds to what we actually see on the die: the new system cache not only has seen a doubling of its slices, but has also outright doubled in capacity from 4 to 8MB.</p><p>Moving onto an analysis of the little cores, things become a bit more complex. At first glance you would believe the A11’s small cores L2 was limited to 512KB and that the A12 goes up to 1.5MB, however what I think is going on is that we’re being tricked by the power management policy of the cache. Looking at the A11 Mistral core latency, we see some obvious jumps at 768KB and 1MB. A similar jump can be seen in the A12 cores at 2MB.</p><p>It’s at this point, where it’s best to go back to the die shots and do some pixel counting, and we come up with the following table:</p><table border=1 cellpadding=0 cellspacing=0><tbody readability=7><tr class=tgrey readability=2><td colspan=3>Measured and Estimated Cache Sizes</td></tr><tr class=tlblue><td class=contentwhite>SoC</td><td class=contentwhite>Apple A12</td><td class=contentwhite>Apple A11</td></tr><tr><td class=tlgrey>Big L1$</td><td>128KB</td><td>64KB</td></tr><tr readability=4><td class=tlgrey>Big L2$</td><td>128 instances<br><strong>6MB</strong>&nbsp;per core/thread<br><strong>8MB total</strong>&nbsp;at 64KB/inst</td><td>128 instances<br><strong>6MB</strong> per core/thread<br at br text-align:><strong>8MB total</strong> at 64KB/inst</td></tr><tr><td class=tlgrey>Small L1$</td><td>32KB</td><td>32KB</td></tr><tr readability=4><td class=tlgrey>Small L2$</td><td>32 instances<br><strong>1.5MB</strong> per core/thread<br><strong>2MB total</strong> at 64KB/inst</td><td>16 + 2(?) instances<br><strong>512KB</strong>&nbsp;per core/thread<br><strong>1MB total</strong> at 64KB/inst</td></tr><tr readability=4><td class=tlgrey>System Cache</td><td>4x 16 instances<br>(double size)<p><strong>8MB</strong> at 128KB/inst</p></td><td>2x 32 instances<p><strong>4MB</strong> at 64KB/inst</p></td></tr></tbody></table><p>The big core L2’s haven’t seen any structural changes between the A11 and A12 – both have 128 instances of SRAM macros, separated into two chunks. The question here remains that if the L2 is indeed just 6MB, then that would mean 48KB per SRAM block.</p><p>When looking at the small cores, we see that they use identical SRAM macros. The A12’s small core L2 has doubled from 16 to 32 instances, meaning there must have been a doubling. However as we see that the measured latency depth of the L2 has at least tripled, something else must be going on. What we’re measuring by no means has to represent what’s in the hardware, and indeed we can confirm this by running the latency test in a more special manner that makes the power management think it’s just some minor workload. On the A12, the Tempest cores then appear to have only 512KB available to them.</p><p>The conclusion is here is that Apple is employing partial cache power-down in what seems to be per-bank granularity. On the A12 each small core L2 bank is 512KB, and on the A11 it’s 256KB. Also, this more strongly leads me to believe there’s 2MB on the A12 and 1MB on the A11, it’s just that the test probably doesn’t fulfill the policy requirements to access the full cache.</p><p>In turn, because this would confirm 64KB per SRAM instance, we can go back and make some hypotheses about the big core L2’s. Again, looking at it, one would believe it stops at 6MB, but looking closer, especially on the A12, there is a change of behaviour at 8MB. Again it’s likely that the cores have 8MB of physical cache, and there’s an obvious change in access behaviour once we’re nearing a full cache.</p><p>The take-away here is that Apple’s caches are just immense, and the A12 further expands in that regard by doubling the system cache size. In practice, we have around 16MB of useable cache hierarchy on the part of the big CPU cores – a massive amount that just puts the memory and cache subsystems of competing SoCs to shame.</p><h3>An evolutionary GPU</h3><p>On the GPU side of things, we had some big expectations from the A12, not merely in terms of performance, but also in terms of architecture. Last year there had been a <a href=#>press release from Imagination</a> stating that Apple had informed them that the company planned to no longer use its IP in new products in 15 to 24 months’ time. This would eventually lead to and crash of the stock price and <a href=#>subsequent sale</a> of the company <a href=#>to an equity firm</a>. &nbsp;</p><p>So while Apple did declare the A11 GPU as an in-house design, it still very much looked like an Imagination derived design, as its block design was very similar to prior Rogue generations – with the big difference being that what was now called a core is the larger structure of what was previously two cores. The fact that it’s still a TBDR (Tile-Based Deferred Renderer), which IMG holds many patents on, but not least the fact that Apple still very much exposes and supports PVRTC (PowerVR Texture Compression), a proprietary format, means that the GPU still likely linked to IMG’s IP. Here it’s likely that we’re still looking at an architectural license design rather than what we would usually call a “clean sheet” design.</p><p><img alt src=https://cdn.statically.io/img/images.anandtech.com/doci/13392/A12-GPU-Core_575px.jpg style=margin:auto;display:block;text-align:center;max-width:100%;height:auto><br>Credit:&nbsp;<a href=#>TechInsights Apple A12</a>&nbsp;Die Shot,&nbsp;<a href=#>ChipRebel Apple A11</a>&nbsp;Die Shot</p><p>Moving onto the A12 GPU – model named as the G11P, we see some very obvious similarities to last year’s A11 GPU. The individual function blocks seem to be largely located the same and constructed in a similar fashion.</p><p>What I think Apple’s biggest advancements in the A12 GPU is the fact that it now supports memory compression. I was very surprised to hear this during the announcement because at the same time it means two things: Prior Apple SoCs and their GPUs apparently didn’t have memory compression, and that now this alone should amount for a very significant boost in performance of the new GPU.</p><p>By memory compression, in particular we mean transparent framebuffer compression from the GPU to main memory. In the desktop space, vendors like Nvidia and AMD have had this for many years now, and it enabled the advancement of GPU performance even in the face of non-advancing memory-bandwidth increases. Smartphone GPUs also require memory compression, not only because of limited bandwidth on mobile SoCs, but most importantly because of the reduced power consumption that is associated with high bandwidth requirements. Arm’s <a href=#>AFBC</a> has been the most publicly talked about mechanism in the mobile space, but other vendors such as Qualcomm or even <a href=#>Imagination</a> have their own implementations.</p><p>Apple seems to be very late to the party in only introducing this with the A12 – however it also means the A12 will benefit from an unusually large generational boost in efficiency and performance, which makes a lot of sense given Apple’s proclaimed large increases for the new GPU.</p><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmivp6x7orrAp5utnZOde6S7zGiqoaenZH50f5hrZq2glWK2sbTOp5xmsKNixbR5zJqvZqqVq7amw4yupa%2BdmaG2r7OMrZ%2BeZaOeuaqvzqdkrJ2Tp7K1v45r</p><footer class=site-footer><span class=site-footer-credits>Made with <a href=https://gohugo.io/>Hugo</a>. © 2022. All rights reserved.</span></footer></section><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/banner.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>